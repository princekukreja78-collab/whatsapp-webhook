// server.cjs ‚Äî MR.CAR webhook (FINAL)
// Auto-port (process.env.PORT), full CRM + Quote + EMI + Bullet-EMI + protections
// Keep crm_helpers.cjs next to it for postLeadToCRM and fetchCRMReply (we call them)

require('dotenv').config();
const fs = require('fs');
const path = require('path');
const express = require('express');
// use global.fetch if available, otherwise node-fetch (v2/v3 compatibility)
const fetch = (global.fetch) ? global.fetch : require('node-fetch');
const app = express();
app.use(express.json());

// -------------------- ENV --------------------
const META_TOKEN      = (process.env.META_TOKEN || process.env.WA_TOKEN || '').trim();
const PHONE_NUMBER_ID = (process.env.PHONE_NUMBER_ID || '').trim();
const ADMIN_WA        = (process.env.ADMIN_WA || '').replace(/\D/g, '') || null;
const VERIFY_TOKEN    = (process.env.VERIFY_TOKEN || process.env.META_VERIFY_TOKEN || '').trim();

const SHEET_TOYOTA_CSV_URL    = (process.env.SHEET_TOYOTA_CSV_URL || '').trim();
const SHEET_HYUNDAI_CSV_URL   = (process.env.SHEET_HYUNDAI_CSV_URL || '').trim();
const SHEET_MERCEDES_CSV_URL  = (process.env.SHEET_MERCEDES_CSV_URL || '').trim();
const SHEET_BMW_CSV_URL       = (process.env.SHEET_BMW_CSV_URL || '').trim();
const SHEET_HOT_DEALS_CSV_URL = (process.env.SHEET_HOT_DEALS_CSV_URL || '').trim();
const SHEET_USED_CSV_URL      = (process.env.SHEET_USED_CSV_URL || '').trim(); // remote URL preferred

const LOCAL_USED_CSV_PATH = path.resolve(__dirname, "PRE OWNED CAR PRICING - USED CAR.csv"); // local fallback if present

// Port auto strategy
const PORT = process.env.PORT || 10000;

// ---------------- Defaults & configs ----------------
const MAX_QUOTE_PER_DAY = Number(process.env.MAX_QUOTE_PER_DAY || 10); // competitor protection
const QUOTE_LIMIT_FILE = path.resolve(__dirname, "quote_limit.json");

const LEADS_FILE = path.resolve(__dirname, "crm_leads.json");

const NEW_CAR_ROI = Number(process.env.NEW_CAR_ROI || 8.10);
const USED_CAR_ROI_VISIBLE = 9.99; // shown to users for used cars
const USED_CAR_ROI_INTERNAL = 10.00; // internal computation rate for bullet math

const DEBUG = process.env.DEBUG_VARIANT === "true" || true;

// ---------------- Helpers: file safe read/write ----------------
function safeJsonRead(filename){
  try {
    if (!fs.existsSync(filename)) return {};
    const txt = fs.readFileSync(filename, 'utf8') || '';
    return txt ? JSON.parse(txt) : {};
  } catch(e) {
    console.warn("safeJsonRead failed", e && e.message ? e.message : e);
    return {};
  }
}
function safeJsonWrite(filename, obj){
  try {
    fs.writeFileSync(filename, JSON.stringify(obj, null, 2), 'utf8');
    return true;
  } catch(e) {
    console.error("safeJsonWrite failed", e && e.message ? e.message : e);
    return false;
  }
}

// ---------------- CRM lead persistence ----------------
function saveLead(lead) {
  try {
    const existing = Array.isArray(safeJsonRead(LEADS_FILE)) ? safeJsonRead(LEADS_FILE) : (safeJsonRead(LEADS_FILE).leads || []);
    // if read returned {} try to load as array
    let arr = Array.isArray(existing) ? existing : (Array.isArray(existing.leads) ? existing.leads : []);
    arr.unshift({ ...lead, ts: Date.now() });
    arr = arr.slice(0, 1000);
    fs.writeFileSync(LEADS_FILE, JSON.stringify(arr, null, 2), 'utf8');
    if (DEBUG) console.log("‚úÖ Lead saved:", lead.from, (lead.text||'').slice(0,120));
    return true;
  } catch (e) {
    console.error("‚ùå Failed to save lead", e && e.message ? e.message : e);
    return false;
  }
}
app.get("/leads", (req, res) => {
  try {
    if (fs.existsSync(LEADS_FILE)) {
      const raw = fs.readFileSync(LEADS_FILE, "utf8") || "[]";
      return res.json(JSON.parse(raw));
    }
    res.json([]);
  } catch (e) { console.warn("GET /leads read error", e); res.json([]); }
});

// ---------------- Quote limits (competitor protection) ----------------
function loadQuoteLimits(){
  const js = safeJsonRead(QUOTE_LIMIT_FILE);
  return js || {};
}
function saveQuoteLimits(obj){ safeJsonWrite(QUOTE_LIMIT_FILE, obj); }
function canSendQuote(from){
  try {
    const q = loadQuoteLimits();
    const today = new Date().toISOString().slice(0,10);
    const rec = q[from] || { date: today, count: 0 };
    if (rec.date !== today) { rec.date = today; rec.count = 0; }
    return rec.count < MAX_QUOTE_PER_DAY;
  } catch(e) { return true; }
}
function incrementQuoteUsage(from){
  try {
    const q = loadQuoteLimits();
    const today = new Date().toISOString().slice(0,10);
    const rec = q[from] || { date: today, count: 0 };
    if (rec.date !== today) { rec.date = today; rec.count = 0; }
    rec.count = Number(rec.count || 0) + 1;
    q[from] = rec;
    saveQuoteLimits(q);
    if (DEBUG) console.log("Quote usage", from, rec);
  } catch(e) { console.warn("incrementQuoteUsage failed", e && e.message ? e.message : e); }
}

// ---------------- WA helpers (send) ----------------
async function waSendRaw(payload) {
  try { console.log("WA OUTGOING PAYLOAD:", { to: payload && payload.to, type: payload && payload.type, sample: (payload && payload.text && payload.text.body) ? String(payload.text.body).slice(0,120) : (payload && payload.interactive) ? "interactive" : null }); } catch(e){}
if (!META_TOKEN || !PHONE_NUMBER_ID) { console.warn("WA skipped - META_TOKEN or PHONE_NUMBER_ID missing"); return null; }
  const url = `https://graph.facebook.com/v20.0/${PHONE_NUMBER_ID}/messages`;
  try {
    const r = await fetch(url, {
      method: "POST",
      headers: { Authorization: `Bearer ${META_TOKEN}`, "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    const j = await r.json().catch(()=>({}));
    if (DEBUG) console.log("WA send response status", r.status, typeof j === 'object' ? JSON.stringify(j).slice(0,800) : String(j).slice(0,800));
    if (!r.ok) {
      console.error("WA send error", r.status, j);
      // handle known unsupported / template / message type errors gracefully
      const code = j?.error?.code || (j?.errors && j.errors[0] && j.errors[0].code) || null;
      if (code === 131051 || code === 131050 || code === 131047) {
        // known unsupported message type / reengagement issues ‚Üí fallback to plain text and notify admin
        try {
          const to = payload && payload.to;
          const fallback = (payload && payload.type === "interactive")
            ? "Sorry ‚Äî your request uses an interactive message type that isn't supported at the moment. Please reply with text."
            : "Message type not supported by API; sending fallback text.";
          if (to) {
            await fetch(`https://graph.facebook.com/v20.0/${PHONE_NUMBER_ID}/messages`, {
              method: "POST",
              headers: { Authorization: `Bearer ${META_TOKEN}`, "Content-Type": "application/json" },
              body: JSON.stringify({ messaging_product:"whatsapp", to, type:"text", text:{ body: fallback } })
            }).catch(()=>{});
          }
        } catch(e){}
        // notify admin (throttled) so you can check the templates
        if (ADMIN_WA) {
          try { waSendText(ADMIN_WA, `‚ö†Ô∏è WA API error ${code} for payload type ${payload && payload.type || 'unknown'} ‚Äî sent fallback.`).catch(()=>{}); } catch(e) {}
        }
      }
    }
    return j;
  } catch(e) {
    console.error("waSendRaw failed", e && e.stack ? e.stack : e);
    return null;
  }
}
async function waSendText(to, body){ return waSendRaw({ messaging_product:"whatsapp", to, type:"text", text:{ body } }); }
async function waSendListMenu(to){
  // Build sections dynamically from configured sheets
  const brands = [];
  if (SHEET_TOYOTA_CSV_URL) brands.push({ id: "BRAND_TOYOTA", title: "Toyota" });
  if (SHEET_HYUNDAI_CSV_URL) brands.push({ id: "BRAND_HYUNDAI", title: "Hyundai" });
  if (SHEET_MERCEDES_CSV_URL) brands.push({ id: "BRAND_MERCEDES", title: "Mercedes" });
  if (SHEET_BMW_CSV_URL) brands.push({ id: "BRAND_BMW", title: "BMW" });
  // fallback default section
  const rows = [
    { id:"SRV_NEW_CAR", title:"New Car Deals", description:"On-road prices & offers" },
    { id:"SRV_USED_CAR", title:"Pre-Owned Cars", description:"Certified used inventory" },
    { id:"SRV_SELL_CAR", title:"Sell My Car", description:"Best selling quote" },
    { id:"SRV_LOAN", title:"Loan / Finance", description:"Fast approvals & low ROI" }
  ];
  const interactive = {
    type: "list",
    header:{ type:"text", text:"MR. CAR SERVICES" },
    body:{ text:"Please choose one option üëá" },
    footer:{ text:"Premium Deals ‚Ä¢ Trusted Service ‚Ä¢ Mr. Car" },
    action:{ button:"Select Service", sections:[ { title:"Available", rows } ] }
  };
  return waSendRaw({ messaging_product:"whatsapp", to, type:"interactive", interactive });
}
async function sendNewCarButtons(to){
  const payload = { messaging_product:"whatsapp", to, type:"interactive", interactive:{
    type:"button", body:{ text:"You can continue with these quick actions:" }, action:{ buttons:[
      { type:"reply", reply:{ id:"BTN_NEW_LOAN", title:"Loan Options" } },
      { type:"reply", reply:{ id:"BTN_NEW_QUOTE", title:"Another Quote" } }
    ]}}};
  return waSendRaw(payload);
}
async function sendUsedCarButtons(to, hasPhotoLink){
  const buttons = [
    { type:"reply", reply:{ id:"BTN_USED_LOAN", title:"Loan Options" } },
    { type:"reply", reply:{ id:"BTN_USED_MORE", title:"More Options" } }
  ];
  if (hasPhotoLink) buttons.unshift({ type:"reply", reply:{ id:"BTN_USED_PHOTOS", title:"View Photos üì∏" } });
  // add bullet calculator quick button
  buttons.push({ type:"reply", reply:{ id:"BTN_BULLET_CALC", title:"Bullet EMI Calculation" } });
  return waSendRaw({ messaging_product:"whatsapp", to, type:"interactive", interactive:{ type:"button", body:{ text:"Quick actions:" }, action:{ buttons } }});
}

// ---------------- admin alerts & throttling ----------------
const lastAlert = new Map();
async function sendAdminAlert({ from, name, text }) {
  if (!META_TOKEN || !PHONE_NUMBER_ID || !ADMIN_WA) return;
  const now = Date.now(); const prev = lastAlert.get(from) || 0;
  const ALERT_WINDOW_MS = (Number(process.env.ALERT_WINDOW_MINUTES || 10)) * 60 * 1000;
  if (now - prev < ALERT_WINDOW_MS) { if (DEBUG) console.log("throttled admin alert for", from); return; }
  lastAlert.set(from, now);
  await waSendRaw({ messaging_product:"whatsapp", to: ADMIN_WA, type:"text",
    text: { body: `üîî NEW WA LEAD\nFrom: ${from}\nName: ${name||'-'}\nMsg: ${String(text||'').slice(0,1000)}` }});
  if (DEBUG) console.log("admin alert sent");
}

// ---------------- CSV utils ----------------
function parseCsv(text){
  const rows=[]; let cur="", row=[], inQ=false;
  for(let i=0;i<text.length;i++){
    const ch=text[i];
    if(inQ){
      if(ch==='"'){ if(text[i+1]==='"'){ cur+='"'; i++; } else inQ=false; }
      else cur+=ch;
    } else {
      if(ch==='"') inQ=true;
      else if(ch===','){ row.push(cur); cur=""; }
      else if(ch==='\n'){ row.push(cur); rows.push(row); row=[]; cur=""; }
      else if(ch!=='\r') cur+=ch;
    }
  }
  if(cur.length||row.length){ row.push(cur); rows.push(row); }
  return rows;
}
async function fetchCsv(url){
  if(!url) throw new Error("CSV URL missing");
  const r = await fetch(url, { cache: "no-store" });
  if(!r.ok) throw new Error(`CSV fetch failed ${r.status}`);
  const txt = await r.text();
  return parseCsv(txt);
}
function toHeaderIndexMap(headerRow){
  const map = {};
  headerRow.forEach((h,i) => { map[String((h||"").trim()).toUpperCase()] = i; });
  return map;
}

// ---------------- Normalization & matching helpers ----------------
function normForMatch(s){
  return (s||"").toString().toLowerCase()
    .replace(/(automatic|automatic transmission|\bauto\b)/g, " at ")
    .replace(/\bautomatic\b/g," at ")
    .replace(/\bauto\b/g," at ")
    .replace(/\bmanual\b/g," mt ")
    .replace(/\bman\b/g," mt ")
    .replace(/[\*\/\\]/g, "x")
    .replace(/\s*x\s*/g, "x")
    .replace(/(\d)\s*x\s*(\d)/g,"$1x$2")
    .replace(/[^a-z0-9\s]/g," ")
    .replace(/\s+/g," ")
    .trim();
}
function fmtMoney(n){ const x=Number(n||0); if(!isFinite(x)) return "-"; return x.toLocaleString("en-IN",{maximumFractionDigits:0}); }
function calcEmiSimple(p, annualRatePct, months){
  const P = Number(p); const r = Number(annualRatePct)/12/100;
  if(!P || !isFinite(r) || months <= 0) return 0;
  const pow = Math.pow(1+r, months);
  const emi = Math.round(P * r * pow / (pow - 1));
  return emi;
}

// ---------------- Greeting throttle & shouldGreetNow ----------------
const lastGreetAt = new Map(); // phone -> timestamp(ms)
const GREET_WINDOW_MIN = Number(process.env.GREET_WINDOW_MIN || 60 * 24); // minutes, default 1 day

function isGreetingText(s){
  if(!s) return true; // treat empty (no-text) as eligible for greet
  const t = String(s||"").toLowerCase().trim();
  // common short greetings
  return /^(hi|hello|hey|namaste|good (morning|afternoon|evening)|hii|helo|yo|start)$/.test(t)
      || (t.length <= 6 && /^[a-z]+$/.test(t)); // very short single words
}

function shouldGreetNow(from, msgText){
  try {
    if (!from) return false;
    const now = Date.now();
    const prev = lastGreetAt.get(from) || 0;
    const diffMin = (now - prev) / 60000;
    // don't greet too frequently
    if (diffMin < GREET_WINDOW_MIN) return false;
    // only greet when message looks like a greeting / first contact / empty
    if (!isGreetingText(msgText)) return false;
    // mark greet time and allow
    lastGreetAt.set(from, now);
    if (DEBUG) console.log("shouldGreetNow -> true for", from, "msg:", String(msgText).slice(0,40));
    return true;
  } catch (e) {
    if (DEBUG) console.warn("shouldGreetNow error", e && e.message ? e.message : e);
    return false;
  }
}

// ---------------- Pricing loader ----------------
const SHEET_URLS = {
  HOT: SHEET_HOT_DEALS_CSV_URL || "",
  TOYOTA: SHEET_TOYOTA_CSV_URL || "",
  HYUNDAI: SHEET_HYUNDAI_CSV_URL || "",
  MERCEDES: SHEET_MERCEDES_CSV_URL || "",
  BMW: SHEET_BMW_CSV_URL || ""
};
const PRICING_CACHE = { tables: null, ts: 0 };
const PRICING_CACHE_MS = 3*60*1000;

async function loadPricingFromSheets(){
  const now = Date.now();
  if (PRICING_CACHE.tables && now - PRICING_CACHE.ts < PRICING_CACHE_MS) return PRICING_CACHE.tables;
  const tables = {};
  for (const [brand, url] of Object.entries(SHEET_URLS)){
    if (!url) continue;
    try {
      const rows = await fetchCsv(url);
      if (!rows || !rows.length) continue;
      const header = rows[0].map(h => String(h||"").trim());
      const idxMap = toHeaderIndexMap(header);
      const data = rows.slice(1);
      tables[brand] = { header, idxMap, data };
    } catch(e) { console.warn("CSV load failed for", brand, e && e.message ? e.message : e); }
  }
  PRICING_CACHE.tables = tables; PRICING_CACHE.ts = Date.now();
  return tables;
}

// ---------------- Used car sheet loader (local fallback) ----------------
async function loadUsedSheet(){
  // prefer remote URL env var
  if (SHEET_USED_CSV_URL){
    try {
      const rows = await fetchCsv(SHEET_USED_CSV_URL);
      if (rows && rows.length) return rows;
    } catch(e) { if (DEBUG) console.warn("remote used csv fetch failed", e && e.message ? e.message : e); }
  }
  // fallback to local file if present
  try {
    if (fs.existsSync(LOCAL_USED_CSV_PATH)){
      const txt = fs.readFileSync(LOCAL_USED_CSV_PATH, 'utf8');
      const rows = parseCsv(txt);
      if (rows && rows.length) return rows;
    }
  } catch(e){ if (DEBUG) console.warn("local used csv read failed", e && e.message ? e.message : e); }
  return [];
}

// ---------------- Bullet EMI simulation (accurate interest) ----------------
/*
 Algorithm:
 - L = loan
 - bullet_total = 25% * L
 - num_bullets = floor(tenure / 12)
 - bullet_each = bullet_total / num_bullets
 - remaining_principal_for_emi = L - bullet_total
 - compute monthly_emi on remaining_principal_for_emi using internal rate USED_CAR_ROI_INTERNAL
 - simulate month-by-month:
    interest = principal * r
    principal_paid_by_emi = monthly_emi - interest
    principal -= principal_paid_by_emi
    if month is bullet month then principal -= bullet_each (and bullet payment incurs interest until that month because principal hasn't been reduced)
 - accumulate interest paid and EMIs and bullet payments
*/
function simulateBulletPlan({ loanAmount, months, internalRatePct, bulletPct=0.25 }){
  const L = Number(loanAmount || 0);
  const N = Number(months || 0);
  const r = Number(internalRatePct || USED_CAR_ROI_INTERNAL) / 12 / 100;
  if (!L || !N || !isFinite(r)) return null;
  const bullet_total = Math.round(L * Number(bulletPct || 0.25));
  const num_bullets = Math.max(1, Math.floor(N / 12));
  const bullet_each = Math.round(bullet_total / num_bullets);
  const principal_for_emi = L - bullet_total;
  // monthly EMI on principal_for_emi
  const monthly_emi = calcEmiSimple(principal_for_emi, internalRatePct, N);
  let principal = principal_for_emi;
  let total_interest = 0;
  let total_emi_paid = 0;
  let total_bullets_paid = 0;
  const schedule = [];
  for (let m = 1; m <= N; m++){
    const interest = Math.round(principal * r);
    let principal_paid_by_emi = monthly_emi - interest;
    if (principal_paid_by_emi < 0) principal_paid_by_emi = 0;
    principal = Math.max(0, principal - principal_paid_by_emi);
    total_interest += interest;
    total_emi_paid += monthly_emi;
    let bullet_paid = 0;
    if (m % 12 === 0) {
      // pay one fraction of total bullet
      bullet_paid = Math.min(bullet_each, Math.max(0, (L - (principal + total_bullets_paid))));
      // In the rare case rounding causes final month difference, adjust final bullet to remaining bullet_total - total bullets paid
      // Simpler: use bullet_each except last bullet adjusts:
      if (m === (num_bullets * 12)) {
        // final bullet adjust
        const already = total_bullets_paid;
        bullet_paid = Math.max(0, bullet_total - already);
      }
      total_bullets_paid += bullet_paid;
      principal = Math.max(0, principal - bullet_paid); // reduce outstanding principal
    }
    schedule.push({ month: m, interest, emi: monthly_emi, principal_remaining: principal, bullet_paid });
  }
  const total_payable = total_emi_paid + total_bullets_paid;
  return {
    loan: L,
    months: N,
    internalRatePct: internalRatePct,
    monthly_emi,
    bullet_total,
    num_bullets,
    bullet_each,
    total_interest,
    total_emi_paid,
    total_bullets_paid,
    total_payable,
    schedule
  };
}

// ---------------- Build used car quote (returns { text, picLink }) ----------------
async function buildUsedCarQuote({ make, model, year }) {
  try {
    // load rows from used sheet
    const rows = await loadUsedSheet();
    if (!rows || !rows.length) return { text: "Used car pricing not configured." };
    const header = rows[0].map(h => String(h||"").toUpperCase());
    const data = rows.slice(1);
    // find make & model indexes
    const makeIdx = header.findIndex(h => h.includes("MAKE"));
    const modelIdx = header.findIndex(h => h.includes("MODEL"));
    // fallback: find best match row
    const makeLower = (make||"").toLowerCase();
    const modelLower = (model||"").toLowerCase();
    let findRow = null;
    for (const r of data) {
      const a = String(r[makeIdx]||"").toLowerCase();
      const b = String(r[modelIdx]||"").toLowerCase();
      if (a.includes(makeLower) && b.includes(modelLower)) { findRow = r; break; }
    }
    if (!findRow) {
      // try fuzzy
      for (const r of data){
        const a = String(r[makeIdx]||"").toLowerCase();
        const b = String(r[modelIdx]||"").toLowerCase();
        if (a.includes(makeLower) || b.includes(modelLower)) { findRow = r; break; }
      }
    }
    if (!findRow) return { text: `Sorry, I couldn‚Äôt find the used car *${make} ${model}* at the moment.` };
    // expected price
    const expectedIdx = header.findIndex(h => h.includes("EXPECTED") || h.includes("EXPECTED PRICE") || h.includes("EXPECTED_PRICE"));
    const expectedStr = expectedIdx >= 0 ? String(findRow[expectedIdx]||"") : "";
    const expected = Number(String(expectedStr||'').replace(/[,‚Çπ\s]/g,'')) || 0;
    // if expected absent, try a numeric column
    let price = expected;
    if (!price) {
      // try any numeric cell
      for (let i=0;i<findRow.length;i++){
        const v = String(findRow[i]||"").replace(/[,‚Çπ\s]/g,"");
        if (/^\d+$/.test(v)) { price = Number(v); break; }
      }
    }
    if (!price) return { text: `Price for *${make} ${model}* not available.` };

    // compute normal EMI on full loan (used car ROI visible)
    const loanAmt = price;
    const normal_emi = calcEmiSimple(loanAmt, USED_CAR_ROI_INTERNAL, 60); // default 60 months for display (we can adjust)
    // For used quote we will show both normal EMI (full loan) and bullet plan (25%)
    const tenureDefault = 60;
    const normalEMI_display = calcEmiSimple(loanAmt, USED_CAR_ROI_INTERNAL, tenureDefault);

    // Bullet plan simulation
    const bulletSim = simulateBulletPlan({ loanAmount: loanAmt, months: tenureDefault, internalRatePct: USED_CAR_ROI_INTERNAL, bulletPct: 0.25 });
    // prepare text parts
    const makeText = String(findRow[makeIdx]||"").toUpperCase();
    const modelText = String(findRow[modelIdx]||"").toUpperCase();
    const lines = [];
    lines.push(`*PRE-OWNED CAR QUOTE*`);
    lines.push(`Make/Model: *${makeText} ${modelText}*`);
    lines.push(price ? `Expected Price: ‚Çπ *${fmtMoney(price)}*` : null);
    lines.push(`ROI (Used Car): *${USED_CAR_ROI_VISIBLE}%* (visible)`);
    lines.push(`Tenure (example): *${tenureDefault} months*`);
    lines.push("");
    // Normal EMI section
    lines.push(`üìå *Normal EMI*`);
    lines.push(`‚Ä¢ EMI (${tenureDefault} months): ‚Çπ *${fmtMoney(normalEMI_display)}*`);
    lines.push("");
    // Bullet EMI section
    if (bulletSim) {
      lines.push(`üìå *Bullet EMI Plan (25% across tenure)*`);
      lines.push(`‚Ä¢ Monthly EMI: ‚Çπ *${fmtMoney(bulletSim.monthly_emi)}*`);
      lines.push(`‚Ä¢ Bullet total (25%): ‚Çπ *${fmtMoney(bulletSim.bullet_total)}*`);
      lines.push(`  ‚Üí ‚Çπ *${fmtMoney(bulletSim.bullet_each)}* on months: ${Array.from({length: bulletSim.num_bullets}, (_,i) => (12*(i+1))).join(" ‚Ä¢ ")}`);
      lines.push("");
      lines.push(`üìä *Total payable (EMIs + bullets):* ‚Çπ *${fmtMoney(bulletSim.total_payable)}*`);
      lines.push(`üí∞ *Interest (approx):* ‚Çπ *${fmtMoney(bulletSim.total_interest)}*`);
      // Add approval note between EMI block and T&C as you requested
      lines.push("");
      lines.push(`‚úÖ *Loan approval possible in ~30 minutes (T&Cs apply)*`);
    }
    lines.push("");
    lines.push(`\n*Terms & Conditions Apply ‚úÖ*`);
    const text = lines.filter(Boolean).join("\n");
    return { text, picLink: null };
  } catch(e){
    console.error("buildUsedCarQuote error", e && e.stack ? e.stack : e);
    return { text: "Used car pricing failed." , picLink:null};
  }
}

// ---------------- Try quick new car quote ----------------
// (Simplified wrapper: loads pricing from sheets and tries to match variant)


async function tryQuickNewCarQuote(msgText, to){
  try {
    if (!msgText || !msgText.trim()) return false;
    if (!canSendQuote(to)) {
      await waSendText(to, "You‚Äôve reached today‚Äôs assistance limit for quotes. Please try again tomorrow or provide your details for a personalised quote.");
      return true;
    }
    const tables = await loadPricingFromSheets();
    if (!tables || Object.keys(tables).length === 0) {
      if (DEBUG) console.log("tryQuickNewCarQuote: pricing tables empty");
      return false;
    }

    const q = String(msgText || "").trim();
    const qnorm = normForMatch(q);
    // tokens from query
    const qTokens = qnorm.split(" ").filter(Boolean);
    if (DEBUG) console.log("tryQuickNewCarQuote: query:", q, "norm:", qnorm, "tokens:", qTokens);

    // detect city & profile (best-effort)
    let city = (q.match(/\b(delhi|chandigarh|chd|gurgaon|noida|mumbai|bangalore|bangalore|blr|chennai|kolkata|hyderabad)\b/)||[])[1] || "delhi";
    if(city==="chd") city="chandigarh";
    const profile = (q.match(/\b(individual|company|corporate|firm|personal)\b/)||[])[1] || "individual";

    let best = {score:0, brand:null, row:null, rowIdx:-1, reason:null, price:0, exShow:0};

    for (const [brand, tab] of Object.entries(tables)){
      if (!tab || !tab.data) continue;
      const header = tab.header.map(h => String(h||"").toUpperCase());
      const idxModel = header.findIndex(h=> h.includes("MODEL") || h.includes("VEHICLE") || h.includes("MAKE"));
      const idxVariant = header.findIndex(h => h.includes("VARIANT") || h.includes("SUFFIX") || h.includes("VAR"));
      const idxKeywords = header.findIndex(h => h.includes("VARIANT_KEYWORDS") || h.includes("VARIANT KEYWORDS") );
      const idxMap = tab.idxMap || toHeaderIndexMap(header);

      if (DEBUG) console.log("Scanning brand", brand, "rows:", (tab.data||[]).length, "idxModel:", idxModel, "idxVariant:", idxVariant, "idxKeywords:", idxKeywords);

      for (let ri=0; ri<tab.data.length; ri++){
        const row = tab.data[ri];
        const cellModel = idxModel>=0 ? normForMatch(String(row[idxModel]||"")) : "";
        const cellVariant = idxVariant>=0 ? normForMatch(String(row[idxVariant]||"")) : "";
        const cellKeywords = idxKeywords>=0 ? normForMatch(String(row[idxKeywords]||"")) : "";

        // score: token overlap with more weight to variant + keywords
        let score = 0;
        for (const tk of qTokens){
          if (!tk || tk.length<2) continue;
          if (cellVariant && cellVariant.includes(tk)) score += 5;
          if (cellKeywords && cellKeywords.includes(tk)) score += 4;
          if (cellModel && cellModel.includes(tk)) score += 2;
          // allow partial match like '4x2' vs '4x2auto' via includes
        }

        // small boost if tokens like '4x2','4x4','zx','zxo','leader','legend','hycross','fortuner' appear
        const boosters = ["4x2","4x4","zx","zxo","leader","legend","hychross","hycross","fortuner","fortunerleader","fortuner leader"];
        for(const b of boosters){ if (qnorm.includes(b) && (cellModel.includes(b) || cellVariant.includes(b) || cellKeywords.includes(b))) score += 6; }

        if (score <= 0) continue;

        // find onroad price heuristically
        let priceIdx = -1;
        const cityToken = city.split(' ')[0].toUpperCase();
        for (const k of Object.keys(idxMap)){
          if (k.includes("ON ROAD") && k.includes(cityToken)) { priceIdx = idxMap[k]; break; }
        }
        if (priceIdx < 0){
          for (let i=0;i<row.length;i++){
            const v = String(row[i]||"").replace(/[,‚Çπ\s]/g,"");
            if (v && /^\d+$/.test(v)) { priceIdx = i; break; }
          }
        }
        const priceStr = priceIdx>=0 ? String(row[priceIdx]||"") : "";
        const onroad = Number(String(priceStr||"").replace(/[,‚Çπ\s]/g,"")) || 0;
        const exShowIdx = detectExShowIdx(idxMap);
        const exShow = exShowIdx>=0 ? Number(String(row[exShowIdx]||"").replace(/[,‚Çπ\s]/g,""))||0 : 0;

        // prefer rows that have numeric price
        if (!onroad) score = Math.max(0, score - 2);

        if (score > best.score){
          best = { score, brand, row, rowIdx:ri, reason: {cellModel, cellVariant, cellKeywords, qTokens}, price: onroad, exShow };
        }
      } // rows
    } // brands

    if (best && best.score > 0){
      if (DEBUG) console.log("tryQuickNewCarQuote: best match", { brand: best.brand, rowIdx: best.rowIdx, score: best.score, price: best.price, exShow: best.exShow, reason: best.reason });
      const row = best.row;
      const header = []; // not needed here
      const idxModel = 0;
      const idxVariant = 3;
      const modelText = (row[idxModel]||"").toUpperCase();
      const variantText = (row[idxVariant]||"").toUpperCase();
      const onroad = best.price;
      const loanAmt = best.exShow || onroad || 0;
      const emi60 = loanAmt ? calcEmiSimple(loanAmt, NEW_CAR_ROI, 60) : 0;
      const lines = [
        `*${best.brand}* ${modelText} ${variantText}`,
        `*Profile:* ${profile.toUpperCase()}`,
        loanAmt ? `*Ex-Showroom:* ‚Çπ ${fmtMoney(loanAmt)}` : null,
        onroad ? `*On-Road:* ‚Çπ ${fmtMoney(onroad)}` : null,
        loanAmt ? `*Loan:* 100% of Ex-Showroom ‚Üí ‚Çπ ${fmtMoney(loanAmt)} @ *${NEW_CAR_ROI}%* (60m) ‚Üí *EMI ‚âà ‚Çπ ${fmtMoney(emi60)}*` : null,
        `\n*Terms & Conditions Apply ‚úÖ*`
      ].filter(Boolean).join("\n");
      await waSendText(to, lines);
      await sendNewCarButtons(to);
      incrementQuoteUsage(to);
      return true;
    }
    if (DEBUG) console.log("tryQuickNewCarQuote: no confident match found for query:", q);
    return false;
  } catch(e){
    console.error("tryQuickNewCarQuote error", e && e.stack ? e.stack : e);
    return false;
  }
}

// helper to detect ex-show index
function detectExShowIdx(idxMap){
  const keys = Object.keys(idxMap);
  let exIdx = -1;
  for (const k of keys){
    if (/EX[\s\-_\/A-Z0-9]*SHOWROOM/.test(String(k))) { exIdx = idxMap[k]; break; }
  }
  // fallback by heuristics
  if (exIdx < 0) {
    const lowerKeys = keys.map(k => k.toLowerCase());
    const i = lowerKeys.findIndex(k => k.includes("ex") && k.includes("showroom"));
    if (i >= 0) exIdx = idxMap[keys[i]];
  }
  return exIdx;
}

// ---------------- CRM helpers (external file) ----------------
let postLeadToCRM = async ()=>{};
let fetchCRMReply = async ()=>{ return null; };
// load crm_helpers.cjs if present
try {
  const crmHelpers = require('./crm_helpers.cjs');
  postLeadToCRM = crmHelpers.postLeadToCRM || postLeadToCRM;
  fetchCRMReply = crmHelpers.fetchCRMReply || fetchCRMReply;
} catch(e) {
  if (DEBUG) console.log("crm_helpers.cjs not loaded (ok for dev).", e && e.message ? e.message : e);
}

// ---------------- Webhook & routing ----------------
app.get("/healthz", (req, res) => res.json({ ok: true, t: Date.now(), debug: DEBUG }));

// META verify (GET)
app.get('/webhook', (req, res) => {
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];
  if (mode === 'subscribe' && token === VERIFY_TOKEN && challenge) {
    console.log("Webhook verified ‚úÖ");
    return res.status(200).type("text/plain").send(String(challenge));
  }
  return res.sendStatus(403);
});

// MAIN handler (POST)
app.post('/webhook', async (req, res) => {
  console.log("üì© Incoming webhook hit:", typeof req.body === 'object' ? JSON.stringify(req.body).slice(0,800) : String(req.body).slice(0,800));
  try {
    const entry = req.body?.entry?.[0];
    const change = entry?.changes?.[0];
    const value = change?.value || {};
    const msg = value?.messages?.[0];
    const contact = value?.contacts?.[0];
    if (!msg) return res.sendStatus(200);

    const from = msg.from;
    const type = msg.type;
    const name = contact?.profile?.name || "Unknown";
    let msgText = "";
    let selectedId = null;
    if (type === "text") msgText = msg.text?.body || "";
    else if (type === "interactive") {
      selectedId = msg.interactive?.button_reply?.id || msg.interactive?.list_reply?.id || null;
      msgText = msg.interactive?.button_reply?.title || msg.interactive?.list_reply?.title || "";
    } else {
      msgText = JSON.stringify(msg);
    }
    if (DEBUG) console.log("INBOUND", { from, type, sample: (msgText||'').slice(0,300) });

    if (from !== ADMIN_WA) await sendAdminAlert({ from, name, text: msgText });

    // non-blocking lead log to CRM and save locally
    try {
      const lead = { from, name, text: msgText };
      postLeadToCRM({ from, name, text: msgText }).catch(()=>{});
      saveLead(lead);
    } catch (e) { console.warn("lead log failed", e && e.message ? e.message : e); }

    // handle interactive choices first
    if (selectedId) {
      switch(selectedId){
        case "SRV_NEW_CAR":
        case "BTN_NEW_QUOTE":
          await waSendText(from, "Please share your *city, model, variant/suffix & profile (individual/company)*.");
          break;
        case "SRV_USED_CAR":
        case "BTN_USED_MORE":
          await waSendText(from, "Share *make, model, year* (optional colour/budget) and I‚Äôll suggest options.");
          break;
        case "SRV_SELL_CAR":
          await waSendText(from, "Please share *car make/model, year, km, city* and a few photos. We‚Äôll get you the best quote.");
          break;
        case "SRV_LOAN":
        case "BTN_NEW_LOAN":
        case "BTN_USED_LOAN":
          await waSendText(from, `For loan assistance, share *city + car model + budget*. New car ROI from *${NEW_CAR_ROI}%*, Used car *${USED_CAR_ROI_VISIBLE}%*.`);
          break;
        case "BTN_USED_PHOTOS":
          await waSendText(from, "Please tap the Google Drive link in the quote to view photos. If missing, reply ‚Äúphotos please‚Äù.");
          break;
        case "BTN_BULLET_CALC":
          await waSendText(from, "To calculate bullet EMI (used car), reply: `bullet <loan amount> <tenure months>` e.g., `bullet 750000 60`");
          break;
        default:
          await waSendText(from, "Thanks! You can type your request anytime.");
      }
      return res.sendStatus(200);
    }

    // Greeting logic
    if (typeof shouldGreetNow === 'function' && shouldGreetNow(from, msgText)){
      await waSendText(from, `üî¥ *MR. CAR* welcomes you!\nNamaste üôè\n\nWe assist with *pre-owned cars*, *new car deals*, *loans* and *insurance*.\nTell us how we can help ‚Äî or pick an option below.`);
      await waSendListMenu(from);
      return res.sendStatus(200);
    }

    // text handling - quick new car quote
    if (msgText && type === "text") {
      // quick new car quote attempt
      const servedNew = await tryQuickNewCarQuote(msgText, from);
      if (servedNew) return res.sendStatus(200);
    }

    // text handling - used car detection
    const usedMatch = (msgText || "").match(/used\s+(?<make>[a-z0-9]+)\s+(?<model>[a-z0-9]+)\s*(?<year>\d{4})?/i)
                    || (msgText || "").match(/(?<make>[a-z0-9]+)\s+(?<model>[a-z0-9]+)\s*(?<year>\d{4})?/i);
    if (usedMatch && usedMatch.groups) {
      const { make, model, year } = usedMatch.groups;
      const q = await buildUsedCarQuote({ make, model, year });
      if (q && q.text) {
        await waSendText(from, q.text);
        await sendUsedCarButtons(from, !!q.picLink);
        return res.sendStatus(200);
      }
    }

    // bullet calculator: "bullet 750000 60" or "bullet 750000"
    const bulletCmd = (msgText||"").trim().match(/^bullet\s+([\d,]+)\s*(\d+)?/i);
    if (bulletCmd) {
      const loanRaw = String(bulletCmd[1]||"").replace(/[,‚Çπ\s]/g,"");
      const months = Number(bulletCmd[2]||60);
      const loanAmt = Number(loanRaw);
      if (!loanAmt || !months) {
        await waSendText(from, "Please send: `bullet <loan amount> <tenure months>` e.g. `bullet 750000 60`");
        return res.sendStatus(200);
      }
      // simulate bullet and reply
      const sim = simulateBulletPlan({ loanAmount: loanAmt, months, internalRatePct: USED_CAR_ROI_INTERNAL, bulletPct:0.25 });
      if (!sim) { await waSendText(from, "Bullet calculation failed."); return res.sendStatus(200); }
      const lines = [];
      lines.push(`üî∑ *Bullet EMI Plan ‚Äî Used Car*`);
      lines.push(`Loan Amount: ‚Çπ *${fmtMoney(sim.loan)}*`);
      lines.push(`ROI (shown): *${USED_CAR_ROI_VISIBLE}%*`);
      lines.push(`Tenure: *${sim.months} months*`);
      lines.push("");
      lines.push(`üìå Monthly EMI (amortising principal excluding bullets): ‚Çπ *${fmtMoney(sim.monthly_emi)}*`);
      lines.push(`üìå Bullet total (25%): ‚Çπ *${fmtMoney(sim.bullet_total)}*`);
      lines.push(`‚Ä¢ Bullet each: ‚Çπ *${fmtMoney(sim.bullet_each)}* on months: ${Array.from({length: sim.num_bullets}, (_,i) => (12*(i+1))).join(" ‚Ä¢ ")}`);
      lines.push("");
      lines.push(`üìä Total payable (EMIs + bullets): ‚Çπ *${fmtMoney(sim.total_payable)}*`);
      lines.push(`üí∞ Total interest (approx): ‚Çπ *${fmtMoney(sim.total_interest)}*`);
      lines.push("");
      lines.push(`‚úÖ *Loan approval possible in ~30 minutes (T&Cs apply)*`);
      lines.push("");
      lines.push(`\n*Terms & Conditions Apply ‚úÖ*`);
      await waSendText(from, lines.join("\n"));
      // tag CRM
      try { postLeadToCRM({ from, name, text: `BULLET_CALC ${loanAmt} ${months}` }); } catch(e){}
      return res.sendStatus(200);
    }

    // emi calculator: "emi 1500000 9.5 60" or "emi 1500000 60"
    const emiCmd = (msgText||"").trim().match(/^emi\s+([\d,]+)(?:\s+([\d\.]+)%?)?\s*(\d+)?/i);
    if (emiCmd) {
      const loanRaw = String(emiCmd[1]||"").replace(/[,‚Çπ\s]/g,"");
      let rate = Number(emiCmd[2] || NEW_CAR_ROI);
      const months = Number(emiCmd[3] || 60);
      const loanAmt = Number(loanRaw);
      if (!loanAmt || !months) {
        await waSendText(from, "Please send: `emi <loan amount> <rate% optional> <tenure months>` e.g. `emi 1500000 9.5 60`");
        return res.sendStatus(200);
      }
      const monthly = calcEmiSimple(loanAmt, rate, months);
      const total = monthly * months;
      const interest = total - loanAmt;
      const lines = [
        `üî∏ EMI Calculation`,
        `Loan: ‚Çπ *${fmtMoney(loanAmt)}*`,
        `Rate: *${rate}%* p.a.`,
        `Tenure: *${months} months*`,
        ``,
        `üìå Monthly EMI: ‚Çπ *${fmtMoney(monthly)}*`,
        `üìä Total Payable: ‚Çπ *${fmtMoney(total)}*`,
        `üí∞ Total Interest: ‚Çπ *${fmtMoney(interest)}*`,
        ``,
        `‚úÖ *Loan approval possible in ~30 minutes (T&Cs apply)*`,
        `\n*Terms & Conditions Apply ‚úÖ*`
      ].join("\n");
      await waSendText(from, lines);
      return res.sendStatus(200);
    }

    // CRM fallback: ask CRM for a reply if no quick quote produced
    try {
      const crmReply = await fetchCRMReply({ from, msgText });
      if (crmReply) { await waSendText(from, crmReply); return res.sendStatus(200); }
    } catch (e) { console.warn("CRM reply failed", e && e.message ? e.message : e); }

    // default fallback
    await waSendText(from, "Tell me your *city + make/model + variant/suffix + profile (individual/company)*. e.g., *Delhi Hycross ZXO individual* or *HR BMW X1 sDrive18i company*.");
    return res.sendStatus(200);
  } catch (err) {
    console.error("Webhook error:", err && err.stack ? err.stack : err);
    try { await waSendText(process.env.ADMIN_WA, `Webhook crash: ${String(err && err.message ? err.message : err)}`); } catch(e){}
    return res.sendStatus(200);
  }
});

// ---------------- start server ----------------
app.listen(PORT, ()=> {
  console.log(`‚úÖ MR.CAR webhook CRM server running on port ${PORT}`);
  console.log("ENV summary:", {
    SHEET_TOYOTA_CSV_URL: !!SHEET_TOYOTA_CSV_URL,
    SHEET_USED_CSV_URL: !!SHEET_USED_CSV_URL || fs.existsSync(LOCAL_USED_CSV_PATH),
    PHONE_NUMBER_ID: !!PHONE_NUMBER_ID, META_TOKEN: !!META_TOKEN, ADMIN_WA: !!ADMIN_WA, DEBUG
  });
});
